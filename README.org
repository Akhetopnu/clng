* Common lisp next generation

This is a template document. Its main goal is to collect ideas and propositions about next generation CL (standard/specification/othername). This way, people can commit their ideas and discuss them in issues. Keep in mind that many things proposed here can be contradictory, and the end result may very well crystallize into several differently designed languages. However, this is a step forward, compared to single messages and abrupt threads found on in different random chats blogs and formus. It is certainly time to at least start accumulating all those ideas. now matter how fundamental or small they are. Main inspiration comes from Common Lisp, but people contributing to this certainly know more than one language.


* Motivation:

Common Lisp standard was created in 1994. One of the main motavations for its creation was uniting many relatively big as well as relatively small dialects of previous Lisp, making it an ultimate successor of MacLisp Lisp series. The natural advantage of this is uniting community forces around a single project, thus getting a large amount of manpower for further development. However, as a result the developers had to try to maintain a ceratin level of backwards compatibility with all the previous existing dialects, resulting in language with different not always consistent with each other features, as well as some historical weight.


** Summary:
So far it seems that all suggestions can be divided into three categories -- fully backwards compatible, almost backwards compatible (with very minor refactorizations required)...and basically a new lisp-based lagnauge. Apparently, the new language sugesstions tend to be way more low-level, as the demand for high-level features is already satisfied by CL high flexibility.

* Alternatives:

+ [[https://common-lisp.net/project/cdr/][CDR Project]]
  The project is mainly focused on backwards compatible suggestions, implementated incrementally.

+ Honorable mention:

[[https://www.cliki.net/Proposed%20Extensions%20To%20ANSI][List of proposed ANSI revisions]]

And there is also [[https://www.cliki.net/Proposed%20ANSI%20Revisions%20and%20Clarifications][List of clarifications]]


* Fully backwards compatible changes:

** High-level features:

+ Extensible loop

  Inextensible loop is the very reasons iterate library exists.

+ Hash tables with arbitrary :test function.

  Also probably typed hash-tables.

** General features:

+ Standard support for weak hash table keys and values.

+ Less undefined behavior

  Very generic statement

+ Standard parser for lambda and macro lambda lists.

  There are a lot of generic half-baked ones.

+ CFFI

  Existing one is said to be somewhat decent but surely there are improvememnts.

** Low-level features:

+ Require numerically equivalent fixnums to be eq.

  They sometimes are and sometimes aren't.

+ Unicode support

  Please.


+ Way to write long string literals split across lines with indentation, without involving format:

````
(foo bar "this is just one \
          \ string literal with only single spaces")
````

+ Expand-full function: perform all expansion on an expression in a given macro environment. Optionally report all free variables.

+ Security (fixing reader eval, ...)

  Or at least, more security on certain areas.

* Almost backwards compatible changes:

+ Extensible sequences

  As well as extensible data structures of different kind.

+ Native lazy list via lazy-cons type which satisfies consp.

  While laziness can be theoretically speaking implemented as a library, the __efficient__ (that is, for production use) laziness is very untrivial to make. Thereofre, maybe it makes sense for
  maintainers of the language implement them (at some point) as a part of "close to standard" library.

+ Standardize the Meta-Object Protocol for CLOS.

  Instead of closer-mop we should have just mop.

+ Sockets

+ GC finalization support: register callback for finalized object.

  The very necessity of gc is a thing to discuss, but at least some control over it is in high demand.

+ Environments

  Standardtized, and a set of baisc functions to wrok with them.

+ Special characters in string literals via something analogous to \x3F, \177, \n, \t, \u+1234.

+ Standardized code walking primitives: one body of user code with no #+this #-that which correctly walks all special forms.

* New (presumably low-level) language:

+ Different kind of polymorphism (or none by default. but ability to implement many)

+ Reader macros overhaul

  Details later.

+ Useful accessors on macro environment objects.

+ Type system overhaul

  A lot of small and big things to add -- proper parametrized types, recursived type definitions, more strict (?) type checks and inference, the ability to adjust it so building something like [[https://github.com/stylewarning/coalton][Coalton]] would be less painful.

+ [[https://pvk.ca/Blog/2013/11/22/the-weaknesses-of-sbcls-type-propagation/][Paul Khuong has many notes on potential compiler improvement, regarding sbcl]]

  While many of those ideas are very specific to sbcl, that blog has a lot of material to consider.

+ Separations into libraries: separate class system

  Separate condition system, separate data structuers library, algorithms library, math library, concurrency library, iteration library, code-walking library, ....

+ Overhaul of path names, w.r.t. current OS landscape.

  One standard way to parse a POSIX or Windows path string to a path name, or a URL. path names should have a :method for this.

+ GC existence.

  This will cause a lot of arguments, and the semantics may change because of it.

** Is this idea new?

Of course not. Attempts to build low level lisps exist, lots of them: [[https://github.com/eudoxia0/corvus][1]], [[https://github.com/tomhrr/dale][2]], [[https://github.com/kiselgra/c-mera][3]], [[https://github.com/eudoxia0/interim][4]] and there are more.
Two things they seemingly lack are: pre-built well defined specification and community visibility and support.


Same can be said about attempts to just upgrade exsiting CL implementation, such as famous CL21.


* Counterarguments

+ Money

+ Time

+ People






* Conclusion
 May not be written until this bulk of this document is finished.
