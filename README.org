* Common lisp next generation

This is a template document. Its main goal is to collect ideas and propositions about next generation CL (standard/specification/othername). This way, people can commit their ideas and discuss them in issues.


* The Motivation:

Common Lisp standard was created in 1994. One of the main motavations for its creation was uniting many relatively big as well as relatively small dialects of previous Lisp, making it an ultimate successor of MacLisp Lisp series. The natural advantage of this is uniting community forces around a single project, thus getting a large amount of manpower for further development. However, as a result the developers had to try to maintain a ceratin level of backwards compatibility with all the previous existing dialects, resulting in language with different not always consistent with each other features, as well as some historical weight.

It has been 26 years, and surely CS theory as well as practice has advanced forward. While many of CL features are relevant nowadays, the number of outdated concepts and ideas had grown. This issue is somewhat mitigated by the outstanding felxibility of the language, but it's not enough. The solution proposed for the next generation standard is to have very low-level fatures standartized -- this combined with imrpoved macro system can make it easy to then add some high level features to the standard as well, implementing them with macros. Should they ever prove inefficient/outdated, it would be much easier to discard them and rebuild something else.

** Summary:
+ Pro:

+ Cons:


* Alternatives:

+ [[https://phoe.tymoon.eu/clus/doku.php?id=start][UltraSpec]]
  The differences are..

+ [[https://common-lisp.net/project/cdr/][CDR Project]]
  The differences are..

+


* Suggestions

** [[https://www.cliki.net/Proposed%20Extensions%20To%20ANSI][List of proposed ANSI revisions]]
And there is also [[https://www.cliki.net/Proposed%20ANSI%20Revisions%20and%20Clarifications][List of clarifications]]


** High-level features:

+ Different kind of polymorphism (or none by default. but ability to implement many)

+ Extensible loop

  Inextensible loop is the very reasons iterate library exists.

+ Extensible sequences

  As well as extensible data structures of different kind.

+ Hash tables with arbitrary :test function.

  Also probably typed hash-tables.

** General features:

+ Native lazy list via lazy-cons type which satisfies consp.

  While laziness can be theoretically speaking implemented as a library, the __efficient__ (that is, for production use) laziness is very untrivial to make. Thereofre, maybe it makes sense for
  maintainers of the language implement them (at some point) as a part of "close to standard" library.

+ Standardize the Meta-Object Protocol for CLOS.

  Instead of closer-mop we should have just mop.

+ Standard support for weak hash table keys and values.

+ Sockets

+ GC finalization support: register callback for finalized object.

  The very necessity of gc is a thing to discuss, but at least some control over it is required.

+ Less undefined behavior

  Very generic statement

+ Environments

  Standardtized, and at least a small set of functions to wrok with them.

+ Reader macros overhaul

  Details later.

+ Useful accessors on macro environment objects.

+ Type system overhaul

  A lot of small and big things to add -- proper parametrized types, recursived type definitions, more strict (?) type checks and inference, the ability to adjust it so building something like [[https://github.com/stylewarning/coalton][Coalton]] would be less painful.

+ Standard parser for lambda and macro lambda lists.

  There are a lot of generic half-baked ones.

+ CFFI

  Existing one is said to be somewhat decent but surely there are improvememnts.

** Low-level features:

+ Require numerically equivalent fixnums to be eq.

  They sometimes are and sometimes aren't.

+ Low-level lisp standartized.

+ [[https://pvk.ca/Blog/2013/11/22/the-weaknesses-of-sbcls-type-propagation/][Paul Khuong has many notes on potential compiler improvement, regarding sbcl]]

  While many of those ideas are very specific to sbcl, that blog has a lot of material to consider.

+ Separations into libraries: separate class system

  Separate condition system, separate data structuers library, algorithms library, math library, concurrency library, iteration library, code-walking library, ....

+ Unicode support

  Please.

+ Special characters in string literals via something analogous to \x3F, \177, \n, \t, \u+1234.

+ Way to write long string literals split across lines with indentation, without involving format:
~~~
(foo bar "this is just one \
          \ string literal with only single spaces")
~~~
+ Standardized code walking primitives: one body of user code with no #+this #-that which correctly walks all special forms.

+ Expand-full function: perform all expansion on an expression in a given macro environment. Optionally report all free variables.

+ Overhaul of path names, w.r.t. current OS landscape.

  One standard way to parse a POSIX or Windows path string to a path name, or a URL. path names should have a :method for this.

+ GC existence.

  This will cause a lot of arguments, and the semantics may change because of it.

+ Security (fixing reader eval, ...)

  Or at least, more security on certain areas.

* Is this idea new?
Of course not. Attempts to build something like this exist, lots of them: [[https://github.com/eudoxia0/corvus][1]], [[https://github.com/tomhrr/dale][2]], [[https://github.com/kiselgra/c-mera][3]], [[https://github.com/eudoxia0/interim][4]] and there are more.
Two things they seemingly lack are: pre-built well defined specification and community visibility and support.

* Counterarguments

+ Money

+ Time

+ People







* Conclusion
